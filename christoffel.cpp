#ifndef _DEF_H
#include "def.h"
#endif

void Christoffel_KRZ(double spin, double krz_d[], double w1, double w2, double CS[][4][4]) {
	double rDg[4][4];
	double thDg[4][4];
	double gg;

	metric_KRZ_rderivatives(spin, krz_d,  w1, w2, rDg);
	metric_KRZ_thderivatives(spin, krz_d, w1, w2, thDg);

	double Dg[4][4][4];
	/*----------------initializing Dg----------------------*/
	for (int i = 0; i <= 3; i++) {
		for (int j = 0; j <= 3; j++) {
			for (int k = 0; k <= 3; k++) {
				if (k == 1)
					Dg[i][j][k] = rDg[i][j];
				else {
					if (k == 2)
						Dg[i][j][k] = thDg[i][j];
					else
						Dg[i][j][k] = 0;
				}
			}
		}
	}
	
	double invg[4][4] = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };
	/*//set all elements zero first
	for (int i = 0; i <= 3; i++) {
		for (int j = 0; j <= 3; j++) {
			invg[i][j] = 0;
		}
	}*/
	double g[4][4]= { { 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 } };
	metric_KRZ(spin, krz_d, w1, w2, g);
	//metric_KRZ_inverse(spin, krz_d[],  w1, w2, invg);
	gg = g[0][0] * g[3][3] - g[0][3] * g[0][3];
	if (std::fabs(gg) > 1e10) {
		invg[0][0] = g[3][3] / gg;
		invg[0][3] = -g[0][3] / gg;
		invg[1][1] = 1 / g[1][1];
		invg[2][2] = 1 / g[2][2];
		invg[3][0] = invg[0][3];
		invg[3][3] = g[0][0] / gg;
	}
	else metric_KRZ_inverse(spin, krz_d, w1, w2, invg);
	/* ----- compute Christoffel symbols ----- */
	/*CS[0][0][0] = 0;
	CS[0][0][1] = (invg[0][0] * Dg[0][0][1] + invg[0][3] * Dg[0][3][1])*0.5;
	CS[0][0][2] = (invg[0][0] * Dg[0][0][2] + invg[0][3] * Dg[0][3][2])*0.5;
	CS[0][0][3] = 0;
	CS[0][1][0] = CS[0][0][1];
	CS[0][1][1] = 0;
	CS[0][1][2] = 0;
	CS[0][1][3] = (invg[0][0] * Dg[0][3][1] + invg[0][3] * Dg[3][3][1])*0.5;
	CS[0][2][0] = CS[0][0][2];
	CS[0][2][1] = 0;
	CS[0][2][2] = 0;
	CS[0][2][3] = (invg[0][0] * Dg[0][3][2] + invg[0][3] * Dg[3][3][2])*0.5;
	CS[0][3][0] = 0;
	CS[0][3][1] = CS[0][1][3];
	CS[0][3][2] = CS[0][2][3];
	CS[0][3][3] = 0;

	CS[1][0][0] = -invg[1][1] * Dg[0][0][1] * 0.5;
	CS[1][0][1] = 0;
	CS[1][0][2] = 0;
	CS[1][0][3] = -invg[1][1] * Dg[0][3][1] * 0.5;
	CS[1][1][0] = 0;
	CS[1][1][1] = invg[1][1] * Dg[1][1][1] * 0.5;
	CS[1][1][2] = invg[1][1] * Dg[1][1][2] * 0.5;
	CS[1][1][3] = 0;
	CS[1][2][0] = 0;
	CS[1][2][1] = CS[1][1][2];
	CS[1][2][2] = -invg[1][1] * Dg[2][2][1] * 0.5;
	CS[1][2][3] = 0;
	CS[1][3][0] = CS[1][0][3];
	CS[1][3][1] = 0;
	CS[1][3][2] = 0;
	CS[1][3][3] = -invg[1][1] * Dg[3][3][1] * 0.5;

	CS[2][0][0] = -invg[2][2] * Dg[0][0][2] * 0.5;
	CS[2][0][1] = 0;
	CS[2][0][2] = 0;
	CS[2][0][3] = -invg[2][2] * Dg[0][3][2] * 0.5;
	CS[2][1][0] = 0;
	CS[2][1][1] = -invg[2][2] * Dg[1][1][2] * 0.5;
	CS[2][1][2] = invg[2][2] * Dg[2][2][1] * 0.5;
	CS[2][1][3] = 0;
	CS[2][2][0] = 0;
	CS[2][2][1] = CS[2][1][2];
	CS[2][2][2] = invg[2][2] * Dg[2][2][2] * 0.5;
	CS[2][2][3] = 0;
	CS[2][3][0] = CS[2][0][3];
	CS[2][3][1] = 0;
	CS[2][3][2] = 0;
	CS[2][3][3] = -invg[2][2] * Dg[3][3][2] * 0.5;

	CS[3][0][0] = 0;
	CS[3][0][1] = (invg[3][3] * Dg[0][3][1] + invg[3][0] * Dg[0][0][1])*0.5;
	CS[3][0][2] = (invg[3][3] * Dg[0][3][2] + invg[3][0] * Dg[0][0][2])*0.5;
	CS[3][0][3] = 0;
	CS[3][1][0] = CS[3][0][1];
	CS[3][1][1] = 0;
	CS[3][1][2] = 0;
	CS[3][1][3] = (invg[3][3] * Dg[3][3][1] + invg[3][0] * Dg[0][3][1])*0.5;
	CS[3][2][0] = CS[3][0][2];
	CS[3][2][1] = 0;
	CS[3][2][2] = 0;
	CS[3][2][3] = (invg[3][3] * Dg[3][3][2] + invg[3][0] * Dg[0][3][2])*0.5;
	CS[3][3][0] = 0;
	CS[3][3][1] = CS[3][1][3];
	CS[3][3][2] = CS[3][2][3];
	CS[3][3][3] = 0;*/

	//Because the Johanson version of code uses 2*CS, so here I multiply CS with two.
	CS[0][0][0] = 0;
	CS[0][0][1] = (invg[0][0] * Dg[0][0][1] + invg[0][3] * Dg[0][3][1]);
	CS[0][0][2] = (invg[0][0] * Dg[0][0][2] + invg[0][3] * Dg[0][3][2]);
	CS[0][0][3] = 0;
	CS[0][1][0] = CS[0][0][1];
	CS[0][1][1] = 0;
	CS[0][1][2] = 0;
	CS[0][1][3] = (invg[0][0] * Dg[0][3][1] + invg[0][3] * Dg[3][3][1]);
	CS[0][2][0] = CS[0][0][2];
	CS[0][2][1] = 0;
	CS[0][2][2] = 0;
	CS[0][2][3] = (invg[0][0] * Dg[0][3][2] + invg[0][3] * Dg[3][3][2]);
	CS[0][3][0] = 0;
	CS[0][3][1] = CS[0][1][3];
	CS[0][3][2] = CS[0][2][3];
	CS[0][3][3] = 0;

	CS[1][0][0] = -invg[1][1] * Dg[0][0][1];
	CS[1][0][1] = 0;
	CS[1][0][2] = 0;
	CS[1][0][3] = -invg[1][1] * Dg[0][3][1];
	CS[1][1][0] = 0;
	CS[1][1][1] = invg[1][1] * Dg[1][1][1];
	CS[1][1][2] = invg[1][1] * Dg[1][1][2];
	CS[1][1][3] = 0;
	CS[1][2][0] = 0;
	CS[1][2][1] = CS[1][1][2];
	CS[1][2][2] = -invg[1][1] * Dg[2][2][1];
	CS[1][2][3] = 0;
	CS[1][3][0] = CS[1][0][3];
	CS[1][3][1] = 0;
	CS[1][3][2] = 0;
	CS[1][3][3] = -invg[1][1] * Dg[3][3][1];

	CS[2][0][0] = -invg[2][2] * Dg[0][0][2];
	CS[2][0][1] = 0;
	CS[2][0][2] = 0;
	CS[2][0][3] = -invg[2][2] * Dg[0][3][2];
	CS[2][1][0] = 0;
	CS[2][1][1] = -invg[2][2] * Dg[1][1][2];
	CS[2][1][2] = invg[2][2] * Dg[2][2][1];
	CS[2][1][3] = 0;
	CS[2][2][0] = 0;
	CS[2][2][1] = CS[2][1][2];
	CS[2][2][2] = invg[2][2] * Dg[2][2][2];
	CS[2][2][3] = 0;
	CS[2][3][0] = CS[2][0][3];
	CS[2][3][1] = 0;
	CS[2][3][2] = 0;
	CS[2][3][3] = -invg[2][2] * Dg[3][3][2];

	CS[3][0][0] = 0;
	CS[3][0][1] = (invg[3][3] * Dg[0][3][1] + invg[3][0] * Dg[0][0][1]);
	CS[3][0][2] = (invg[3][3] * Dg[0][3][2] + invg[3][0] * Dg[0][0][2]);
	CS[3][0][3] = 0;
	CS[3][1][0] = CS[3][0][1];
	CS[3][1][1] = 0;
	CS[3][1][2] = 0;
	CS[3][1][3] = (invg[3][3] * Dg[3][3][1] + invg[3][0] * Dg[0][3][1]);
	CS[3][2][0] = CS[3][0][2];
	CS[3][2][1] = 0;
	CS[3][2][2] = 0;
	CS[3][2][3] = (invg[3][3] * Dg[3][3][2] + invg[3][0] * Dg[0][3][2]);
	CS[3][3][0] = 0;
	CS[3][3][1] = CS[3][1][3];
	CS[3][3][2] = CS[3][2][3];
	CS[3][3][3] = 0;
}
